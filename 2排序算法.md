# 排序算法

*  **插入排序**
   + **直接插入**
      + **原理**：每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。
      具体方法是第一趟比较前两个数，然后把第二个数按大小插入到有序表中； 第二趟把第三个数据与前两个数从前向后扫描，把第三个数按大小插入到有序表中；依次进行下去，进行了(n-1)趟扫描以后就完成了整个排序过程。它是由两层嵌套循环组成的，外层循环标识并决定待比较的数值，内层循环为待比较数值确定其最终位置。直接插入排序是将待比较的数值与它的前一个数值进行比较，所以外层循环是从第二个数值开始的。当前一数值比待比较数值大的情况下继续循环比较，直到找到比待比较数值小的并将待比较数值置入其后一位置，结束该次循环。
      +  **示例说明**
      + **Python3实现**
      ```
       # 直接插入排序
       def Insert(listdata):
           for i in range(1, len(listdata)):
               # 设置当前值前一个元素的标识
               j = i - 1
               # 如果当前值小于前一个元素,则将当前值作为一个临时变量存储,将前一个元素后移一位
               if listdata[i] < listdata[j]:
                   temp, listdata[i] = listdata[i], listdata[j]
                   # 继续往前寻找,如果有比临时变量大的数字,则后移一位,直到找到比临时变量小的元素或者达到列表第一个元素
                   j = j - 1
                   while j >= 0 and listdata[j] > temp:
                       listdata[j + 1] = listdata[j]
                       j = j - 1
                   # 将临时变量赋值给合适位置
                   listdata[j + 1] = temp
           return listdata
      ```
    + **希尔**
      + **原理**：将待排序列划分为若干组，在每一组内进行插入排序，以使整个序列基本有序，然后再对整个序列进行插入排。
      + **示例说明**
      
        待排序数组：{6, 5, 3, 1, 8, 7, 2, 4, 9, 0}
        
        **第一次步长h=4**,那么数组按照步长可以拆分成4个小数组（[0]6的意思是下标[0]的值为6）

        {[0]6, [4]8, [8]9}，
        {[1]5, [5]7, [9]0}，
        {[2]3, [6]2}，
        {[3]1, [7]4}

        对这4个小数组分别进行插入排序后，4个小数组变成：
        
        {[0]6, [4]8, [8]9}，
        {[1]0, [5]5, [9]7}，
        {[2]2, [6]3}，
        {[3]1, [7]4}，
        
        合并起来就是：{6, 0, 2, 1, 8, 5, 3, 4, 9, 7}

        **第二次步长h=1**,那么数组按照步长只有1个数组了
        
        {6, 0, 2, 1, 8, 5, 3, 4, 9, 7}

        对这个数组进行一次插入排序后，最终顺序就成为：
        
         {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
         
         增量的选取会影响算法的时间复杂度
    
      + Python3实现   
      ```
      # 希尔排序
      def Shell(listdata):
          n = len(listdata)
          # 希尔增量
          gap = int(n / 2)
          while gap > 0:
              # 按增量进行直接插入排序
              for i in range(gap, n):
                  j = i
                  # 直接插入排序
                  while j >= gap and listdata[j - gap] > listdata[j]:
                      listdata[j - gap], listdata[j] = listdata[j], listdata[j - gap]
                      j -= gap
              # 得到新的增量
              gap = int(gap / 2)
          return listdata
     ```
      
      
*  **选择排序**
   + **直接选择**
      + 原理：
    
      + Python3实现
      
    + **堆**
      + 原理：
    
      + Python3实现        
    
*  **交换排序**
   + **冒泡**
      + 原理：
    
      + Python3实现
      
    + **快速**
      + 原理：
    
      + Python3实现        
    
